#!/bin/bash
# Made by David De Grave, 2017
# david.degrave@mind.be

# CONFIG
PROJECT="project1"
BOARD="x86_64"
SUFFIX="master"

BUILDROOT_REPO="git://git.buildroot.net/buildroot.git"
BUILDROOT_BRANCH_NAME="master"
###

BASE_DIR="${PWD}"
CONFIG_DIR="${BASE_DIR}/configs"
BUILD=${PROJECT}_${BOARD}
DEFCONFIG="${PROJECT}_${BOARD}_defconfig"
OUTPUT="${BASE_DIR}/o-${BUILD}"

if [ ! -f "${CONFIG_DIR}/$DEFCONFIG" ]; then
	echo "defconfig '$DEFCONFIG' not found !"
	exit 2
fi

extra="BR2_EXTERNAL=../projects/${PROJECT}"
debug=0
rebuild=0
reinstall=0
quiet=0

while [ "${1:0:2}" == '--' ]; do
	case $1 in
	 --j)           extra+=" BR2_JLEVEL=$2"; shift;;
	 --rebuild)	rebuild=1;;
	 --reinstall)   reinstall=1;;
	 --debug)	debug=1;;
	 --quiet)	quiet=1;;
	 *)
	 	echo "--rebuild   Restart the build from scratch"
		echo "--reinstall Force the reinstall of target without a full rebuild"
	 	echo "--debug     Create a debug build"
	 	echo "--quiet     Create a log file and show lesser outputs"
		echo "--j <n>     Use max <n> cpus"
	 	exit;;
	esac
	shift
done

clone_if_new() {
# Clone a repository if it doesn't exist yet
# $1 = directory name, e.g. buildroot
# $2 = remote repository, e.g. $BUILDROOT_REPO
# $3 = branch name, e.g. master
	if [ ! -d "$1" ]; then

		if ! git ls-remote --heads "$2" "$3" > /dev/null; then
			printf "Repository %s is not accessible\n" "$2"
			printf "Make sure that:\n"
			printf "\t1. Your ssh key is registered at bitbucket.\n"
			printf "\t2. You have (read) access to this repository.\n"
			printf "\t3. The branch %s exists in the repository.\n" "$3"
			exit 1
		fi
		
		printf "%s/Makefile does not exist, clone...\n" "$1"
		printf "git clone --branch %s %s %s\n" "$3" "$2" "$1"

		git clone --branch "$3" "$2" "$1" || exit $?
	fi
}

clone_if_new buildroot "$BUILDROOT_REPO" "$BUILDROOT_BRANCH_NAME"

if   [ $rebuild -eq 1 ]; then
	read -p "Sure to cleanup everything ?!! (CTRL-C to abord)"
	[ -e "$OUTPUT/debug_build" ] && mv "$OUTPUT/debug_build" /tmp/~debug_build.$$
	rm -rf "$OUTPUT" "$OUTPUT.log"
elif [ $reinstall -eq 1 ]; then
	find $OUTPUT/build -regex '.*\.stamp_.*\(built\|installed\)' -delete
	rm -rf $OUTPUT/{final,staging} $OUTPUT/{host,images,target}/*
fi

if [ ! -e "$OUTPUT" ]; then
	mv /tmp/~debug_build.$$ "$OUTPUT/debug_build" 2>/dev/null
	if [ $debug -eq 1 ]; then
		[ -e "$OUTPUT/debug_build" ] || cp -a configs/debug_build "$OUTPUT"
		${EDITOR:-vi} "$OUTPUT/debug_build"
		touch "$OUTPUT/debug_build"
	fi
	make -C buildroot "O=$OUTPUT" $extra defconfig BR2_DEFCONFIG=$CONFIG_DIR/$DEFCONFIG
	make -C buildroot "O=$OUTPUT" $extra source
fi

quiet() {
    local found ret start d h m mf

    if ! which unbuffer >/dev/null 2>&1; then
        printf "you need to install 'unbuffer' (from package expect or expect-dev)\n" >&2
        exit 1
    fi

    start=${SECONDS}

    ( exec 2>&1; unbuffer make -C buildroot "O=$OUTPUT" $extra "${@}"; ) \
    > >( while read line; do
             printf "%(%H:%M:%S)T %s\n" -1 "${line}"
         done \
         |tee -a ${BUILD}.log \
         |grep --colour=never -E '>>>'
       )
    ret=${?}

    d=$((SECONDS-start))
    printf "Done in "
    h=$((d/3600))
    d=$((d%3600))
    [ ${h} -eq 0 ] || { printf "%dh " ${h}; mf="02"; }
    m=$((d/60))
    d=$((d%60))
    [ ${m} -eq 0 ] || { printf "%${mf}dmin " ${m}; sf="02"; }
    printf "%${sf}ds" ${d}

    if [ ${ret} -ne 0 ]; then
        printf "  (error code: %s)" ${ret}
    fi
    printf "\n"

    return ${ret}
}

normal() {

	make -C buildroot "O=$OUTPUT" $extra "$@"

}
echo -e "\e[1;33m>>> START" $(date) "\e[0m"
[ $quiet -eq 1 ] && quiet "${@}" || normal "${@}"
echo -e "\e[1;33m>>> END" $(date) "\e[0m"
